#!/usr/bin/python3
# -*- coding: utf-8 -*-

import argparse
from bs4 import BeautifulSoup
import html
import json
import os
from parsel import Selector
from queue import Queue
import re
import requests
from subprocess import Popen, PIPE
from threading import Thread

parser = argparse.ArgumentParser()
parser.add_argument('movie_title', help="Cerca una stringa specifica nel titolo, per elencare tutti i film usare \"\" (vuoto)")

parser.add_argument("-l", "--list", help="Elenca semplicemente i film trovati dalla ricerca (senza ulteriori dati, per velocizzare la ricerca, \
                    non sarÃ  possibile usare --min-year, --max-year e --min-rating)",
                    action="store_true", default=False)
parser.add_argument("--min-year", help="Imposta l'anno minimo dei film da elencare", type=int)
parser.add_argument("--max-year", help="Imposta l'anno minimo dei film da elencare (oggi, se assente)", type=int)
parser.add_argument("--min-rating", help="Imposta il rating minimo dei film da elencare", type=int)

parser.add_argument("-r", "--rating", help="Ordina i film per IMdb rating", action="store_true", default=False)
parser.add_argument("-y", "--year", help="Ordina i film per anno di rilascio", action="store_true", default=False)

parser.add_argument("-d", "--download", help="Aggiungi il link mega alla coda download (richiede mega-cli installato)",
                    action="store_true", default=False)
parser.add_argument("-p", "--path",
                    help="Imposta un percorso per il download, se assente scarica nella directory corrente")

parser.add_argument("-i", "--info", help="Visualizza tutti i dettagli del film da IMdb", action="store_true", default=False)

parser.add_argument("--backup", help="Crea una cartella 'backup' ed esporta tutti i dati sui film di hd4me e relativi file data in quella cartella", action="store_true", default=False)

args = parser.parse_args()


def main():
    hd4me_source = requests.get('https://hd4me.net/lista-film', timeout=10)
    selector = Selector(hd4me_source.text)

    titles = selector.xpath("//li[@class='title_item']/a[1]/text()").getall()
    links = selector.xpath("//li[@class='title_item']/a[1]/@href").getall()

    data = dict(zip(titles, links))

    movies = {}
    threads = []
    q = Queue()

    for full_title, download_link in data.items():

        try:
            hd4me_title = re.search(r"(^.*)\s\(", full_title)[1]
        except:
            hd4me_title = full_title

        if args.movie_title.lower() in hd4me_title.lower():

            hd4me_page = requests.get("https://hd4me.net/" + download_link.replace("?p=", ""))
            mega_link = ""

            mega_link = get_megalink(hd4me_page)
            imdb_id = get_imdb_id(hd4me_page)

            if args.list:
                print(hd4me_title, download_link)
                continue

            elif args.backup:
                if not os.path.exists(os.getcwd() + "/backup"):
                    os.mkdir(os.getcwd() + "/backup")

                info = get_medialink(hd4me_page)
                media_info = requests.get(info)

                try:
                    media_title = re.search(r"(Nome\:\s(.*)(.mkv|.avi))", media_info.text)[2]
                except:
                    media_title = full_title
                print(media_title)

                # Write the media info file
                f = open(os.getcwd() + "/backup/" + media_title.replace("/", "-") + ".txt", "w")
                f.write(media_info.text)
                f.close()

                # Append the file data into the csv
                f = open(os.getcwd() + "/backup/hd4me_movies.txt", "a")
                f.write("%s,%s,%s,%s\n" % (hd4me_title, media_title, mega_link, imdb_id))
                f.close()

                continue

            else:
                t = Thread(target=get_imdb_json, args=(imdb_id, hd4me_title, mega_link, q, ), name=full_title)
                t.start()
                threads.append(t)

    for t in threads:
        t.join()

    while not q.empty():
        imdb_json = q.get()

        plot = imdb_json['description']
        imdb_title = imdb_json['imdb_title']
        hd4me_title = imdb_json['hd4me_title']
        genres = imdb_json['genre']
        rating = imdb_json['rating']
        date_published = imdb_json['datePublished']
        year = int(imdb_json['year'])
        mega_link = imdb_json['mega_link']

        m = Movie(hd4me_title, imdb_title, date_published, rating, genres, plot, mega_link)

        if args.min_year and args.max_year and args.min_rating:
            if year >= args.min_year and year <= args.max_year and rating >= args.min_rating:
                movies[hd4me_title] = m

        elif args.min_year and args.max_year:
            if year >= args.min_year and year <= args.max_year:
                movies[hd4me_title] = m

        elif args.min_year:
            if year >= args.min_year:
                movies[hd4me_title] = m

        elif args.max_year:
            if year <= args.min_year:
                movies[hd4me_title] = m

        elif args.min_rating:
            if rating >= args.min_rating:
                movies[hd4me_title] = m

        else:
            movies[hd4me_title] = m

    if args.rating:
        movies = sort_by_rating(movies)

    if args.year:
        movies = sort_by_year(movies)

    for title, movie in movies.items():
        if args.info:
            print("%s (Data rilascio: %s, IMDB Rating: %s)\nDownload link: %s\nGenere: %s\nTrama: %s\n---" %
                  (movie.imdb_title, movie.date_published, movie.rating, movie.mega_link, movie.genres, movie.plot))
        else:
            print("%s - (%s, %s - rating: %s)" % (movie.hd4me_title, movie.imdb_title, movie.date_published, movie.rating))

        if args.download:

            if args.path:
                print("Download in " + args.path)
                p = Popen(["mega-get", "-q", "--ignore-quota-warn", movie.mega_link, args.path], stdout=PIPE,
                          stderr=PIPE)
            else:
                print("Download in " + os.getcwd())
                p = Popen(["mega-get", "-q", "--ignore-quota-warn", movie.mega_link], stdout=PIPE, stderr=PIPE)

            output, error = p.communicate()

            if p.returncode != 0:
                print("Errore download: %s" % (output.decode('ascii')))
            else:
                print("Download iniziato")


def get_megalink(response):
    m_selector = Selector(response.text)

    try:
        hd4me_link = m_selector.xpath('//a[@class="bot1"]/@href').get()
        return hd4me_link.replace('https://hd4me.net/?', 'https://mega.nz/#')
    except:
        return m_selector.xpath('//a[@class="bot"]/@href').get()


def get_medialink(response):
    m_selector = Selector(response.text)
    hd4me_mediainfo_link = m_selector.xpath('//a[@class="bot"]/@href').get()

    return (hd4me_mediainfo_link)


def get_imdb_id(response):

    i_selector = Selector(response.text)
    imdb_id = i_selector.xpath('//div[@class="imdbRatingPlugin"]/@data-title').get()

    if imdb_id is None:
        imdb_id = i_selector.xpath('//span[@class="imdbRatingPlugin"]/@data-title').get()

    return imdb_id


def get_imdb_json(imdb_id, hd4me_title, mega_link, queue):

    imdb_json = json.loads('''
    {
      "imdb_title": "Not found",
      "hd4me_title": "''' + hd4me_title + '''",
      "description": "Not found",
      "rating": "N/A",
      "genre": ["N/A"],
      "datePublished": "N/A",
      "duration": "N/A",
      "year": "N/A",
      "mega_link": "''' + mega_link + '''"
    }
    ''')

    try:
        f = requests.get('https://www.imdb.com/title/' + imdb_id, timeout=10)
    except:
        queue.put(imdb_json)
    else:
        bf = BeautifulSoup(f.content, 'html.parser')
        script = bf.find_all('script')[2]
        imdb_data = json.loads(script.text)

        imdb_json["imdb_title"] = html.unescape(imdb_data['name'])
        imdb_json["hd4me_title"] = hd4me_title
        imdb_json["description"] = imdb_data['description']
        imdb_json["genre"] = ", ".join(imdb_data['genre'])
        imdb_json["rating"] = imdb_data['aggregateRating']['ratingValue']
        imdb_json["datePublished"] = imdb_data['datePublished']
        imdb_json["year"] = imdb_data['datePublished'][0:4]
        imdb_json["mega_link"] = mega_link

        queue.put(imdb_json)


def sort_by_rating(movies):
    sorted_movies = sorted(movies.items(), key=lambda x: x[1].rating, reverse=True)
    return dict(sorted_movies)


def sort_by_year(movies):
    sorted_movies = sorted(movies.items(), key=lambda x: x[1].date_published, reverse=True)
    return dict(sorted_movies)


class Movie:
    def __init__(self, hd4me_title, imdb_title, date_published, rating, genres, plot, mega_link):
        self.hd4me_title = hd4me_title
        self.imdb_title = imdb_title
        self.date_published = date_published
        self.rating = rating
        self.genres = genres
        self.plot = plot
        self.mega_link = mega_link


if __name__ == '__main__':
    main()
